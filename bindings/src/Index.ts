
import { Project } from "ts-morph";
import fs from 'fs';

const project = new Project({
  tsConfigFilePath: "./src/target.tsconfig.json"
});

let outputFilePath = "../src/gen/Bindings_Generated.ts";
fs.writeFileSync(outputFilePath, "");
const stream = fs.createWriteStream(outputFilePath);
stream.write(`///
/// THIS FILE HAS BEEN AUTOGENERATED
///
/// DO NOT EDIT MANUALLY
///

/// Imports
import { InstallBuiltIn } from "../BuiltIns/InstallBuiltIn";
import { SRootSymbolTable } from "../SLocalSymbolTable";
import { SValues } from "../SValues/AllSValues";
import type { SMetadataProvider } from "../SMetadataProvider";
import type { SValue } from "../SValues/SValue";

/// Main entry point for installing all generated bindings.
export const installGeneratedBindings: InstallBuiltIn<any> = (rootSTable: SRootSymbolTable<any>) => {
`);
const makeAppendToFileWithIndentationFunction = (writeFunc: (appendStr: string) => void) => {
  return (indentation: number) => {
    let indentationStr = "";
    for (let index = 0; index < indentation; index++) {
      indentationStr += "  ";
    }
    const writeFuncWithIndent = (appendStr: string) => {
      const pieces = appendStr.trim().split("\n");
      for (const piece of pieces) {
        writeFunc("\n" + indentationStr + piece);
      }
    };
    // todo
    // writeFunc.increaseIndentation = (increaseAmt: number = 1) => {
    //   return 
    // }
    return writeFuncWithIndent;
  };
};
const makeAppendToFileWithIndentation = makeAppendToFileWithIndentationFunction((str)=>stream.write(str));
const appendToFile = makeAppendToFileWithIndentation(1);

const target = "lib.es2015.d.ts";
// const target = "lib.esnext.d.ts";
// const target = "lib.d.ts";
// const target = "lib.es5.d.ts";

const filesToDoWorkOn: string[] = [];
function importFileRecursively(fileName: string) {
  const filePath = "./src/tslib/" + fileName;
  if (filesToDoWorkOn.includes(filePath) === false) {
    filesToDoWorkOn.push(filePath);
  }
  console.log("Importing " + filePath);
  project.addSourceFileAtPath(filePath);
  const file = project.getSourceFileOrThrow(filePath);
  const libReferenceDirectives = file.getLibReferenceDirectives();
  for (const libReferenceDirective of libReferenceDirectives) {
    const fileName = "lib." + libReferenceDirective.getFileName() + ".d.ts";
    importFileRecursively(fileName);
  }
}
importFileRecursively(target);

function doFileWork(filePath: string) {
  console.log("Doing work on " + filePath);
  const file = project.getSourceFileOrThrow(filePath);
//   // const interfaces = file.getInterfaces();
//   // for (const anInterface of interfaces) {
//   //   console.log(anInterface.getType().getText())
//   // }
  const decls = file.getVariableDeclarations();
  for (const decl of decls) {
    const globalVariableName = decl.getStructure().name;
    if (globalVariableName !== "Number") {
      // skipping others for now
      continue;
    }
    const swizzleOrWhiteListModel: SwizzleOrWhiteListEntry[] = [];
    swizzleOrWhiteListModel.push({
      kind: "hardcoded",
      code: `
swizzled_apply_raw(sThisArg: SValue<any>, sArgArray: SValue<any>[], mProvider: SMetadataProvider<any>): SValue<any> {
  throw new Error("todo!");
}`});
    const declType = decl.getType();
    const typeProperties = declType.getProperties();
    // const baseTypes = declType.getPropertyOrThrow("EPSILON");
    // console.log(baseTypes, "baseTypes")
    for (const typeProperty of typeProperties) {
      const propertyName = typeProperty.getName();
      const propertyDeclarations = typeProperty.getDeclarations();
      if (propertyDeclarations.length !== 1) {
        console.log(`Handle more than 1 (or 0?) property declarations for whitelist/swizzling property ${propertyName}`)
        continue;
      }
      const propertyDeclaration = propertyDeclarations[0];
      const propertyType = propertyDeclaration.getType();
      if (propertyName === "prototype") {
        /// special treatment for prototype swizzling
        // todo
        continue;
      } else {
        // is a primitive
        if (propertyType.isBoolean() || propertyType.isNumber()) {
          // whitelist it!
          // todo: force the user who is generating the bindings to opt-in to white listing for safety
          swizzleOrWhiteListModel.push({
            kind: "hardcoded",
            code: `whitelist_${propertyName}: true`
          });
          continue;
        } else {
          console.log(`Handle non-primitive whitelist/swizzling property ${propertyName} of type ${propertyType.getText()}`);
          continue;
        }
      }
    }
    let swizzleOrWhiteListModelStr = "";
    const appendToSwizzleOrWhiteListModelStrWithIndentation = makeAppendToFileWithIndentationFunction((str)=>swizzleOrWhiteListModelStr+=str);
    const appendToSwizzleOrWhiteListModelStr = appendToSwizzleOrWhiteListModelStrWithIndentation(2);
    for (const swizzleOrWhiteListEntry of swizzleOrWhiteListModel) {
      if (swizzleOrWhiteListEntry.kind === "hardcoded") {
        appendToSwizzleOrWhiteListModelStr(swizzleOrWhiteListEntry.code + ",");
      } else {
        throw new Error("Todo kind "+ swizzleOrWhiteListEntry.kind);
      }
    }
    appendToFile(`
/// Native binding to global variable "${globalVariableName}".
rootSTable.assign("${globalVariableName}", SValues.SFunction.createFromNative(
  ${globalVariableName},
  {
    ${swizzleOrWhiteListModelStr.trim()}
  },
  new SValues.SNullValue(rootSTable.newMetadataForCompileTimeLiteral()), // todo: change to function
  rootSTable.newMetadataForCompileTimeLiteral()
), "const");
`);
  }
}
for (const fileToDoWorkOn of filesToDoWorkOn) {
  doFileWork(fileToDoWorkOn);
}

project.createSourceFile("test.ts",`let w = Number.NaN`);
const sourceFile = project.getSourceFiles()[0];
console.log(sourceFile.getVariableDeclarationOrThrow("w").getType().getText());


stream.write(`
};`);



type SwizzleOrWhiteListEntry = HardCodedSwizzleOrWhiteListEntry & {
  kind: string
};
interface HardCodedSwizzleOrWhiteListEntry {
  kind: "hardcoded"
  code: string
}
