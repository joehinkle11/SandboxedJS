
import { Project, Signature, TypeFormatFlags } from "ts-morph";
import fs from 'fs';
import { convertTypeToSValue, NativeToSValueConversionCode } from "./ConvertTypeToSValue";
import { ParamExtraction, extractParameters } from "./ExtractParameters";
import { isValidJsPropertyName } from "./Utils";
import { globalPrimitiveDeclaration } from "./GlobalPrimitiveDeclaration";

const project = new Project({
  tsConfigFilePath: "./src/target.tsconfig.json"
});

let outputFilePath = "../src/gen/Bindings_Generated.ts";
fs.writeFileSync(outputFilePath, "");
const stream = fs.createWriteStream(outputFilePath);
stream.write(`///
/// THIS FILE HAS BEEN AUTOGENERATED
///
/// DO NOT EDIT MANUALLY
///

/// Imports
import { SValues } from "../SValues/AllSValues";
import type { InstallBuiltIn } from "../BuiltIns/InstallBuiltIn";
import type { SLocalSymbolTable, SRootSymbolTable } from "../SLocalSymbolTable";
import type { SMetadataProvider } from "../SMetadataProvider";
import type { SNormalObject } from "../SValues/SObjects/SNormalObject";
import type { SFunction } from "../SValues/SObjects/SFunction";
import type { SNumberValue } from "../SValues/SPrimitiveValues/SNumberValue";
import type { SValue } from "../SValues/SValue";

/// Helpers
const getArg: (sArgArray: SValue<any>[], index: number, sTable: SLocalSymbolTable<any>) => SValue<any> = (sArgArray, index, sTable) => {
  return sArgArray[index] ?? new SValues.SUndefinedValue(sTable.newMetadataForRuntimeTimeEmergingValue());
}

/// Main entry point for installing all generated bindings.
export const installGeneratedBindings: InstallBuiltIn<any> = (rootSTable: SRootSymbolTable<any>) => {
`);
const makeAppendToFileWithIndentationFunction = (writeFunc: (appendStr: string) => void) => {
  return (indentation: number) => {
    let indentationStr = "";
    for (let index = 0; index < indentation; index++) {
      indentationStr += "  ";
    }
    const writeFuncWithIndent = (appendStr: string) => {
      const pieces = appendStr.trim().split("\n");
      for (const piece of pieces) {
        writeFunc("\n" + indentationStr + piece);
      }
    };
    // todo
    // writeFunc.increaseIndentation = (increaseAmt: number = 1) => {
    //   return 
    // }
    return writeFuncWithIndent;
  };
};
const makeAppendToFileWithIndentation = makeAppendToFileWithIndentationFunction((str)=>stream.write(str));
const appendToFile = makeAppendToFileWithIndentation(1);

const target = "lib.es2015.d.ts";
// const target = "lib.esnext.d.ts";
// const target = "lib.d.ts";
// const target = "lib.es5.d.ts";

const filesToDoWorkOn: string[] = [];
function importFileRecursively(fileName: string) {
  const filePath = "./src/tslib/" + fileName;
  if (filesToDoWorkOn.includes(filePath) === false) {
    filesToDoWorkOn.push(filePath);
  }
  console.log("Importing " + filePath);
  project.addSourceFileAtPath(filePath);
  const file = project.getSourceFileOrThrow(filePath);
  const libReferenceDirectives = file.getLibReferenceDirectives();
  for (const libReferenceDirective of libReferenceDirectives) {
    const fileName = "lib." + libReferenceDirective.getFileName() + ".d.ts";
    importFileRecursively(fileName);
  }
}
importFileRecursively(target);

function doFileWork(filePath: string) {
  console.log("Doing work on " + filePath);
  const file = project.getSourceFileOrThrow(filePath);
//   // const interfaces = file.getInterfaces();
//   // for (const anInterface of interfaces) {
//   //   console.log(anInterface.getType().getText())
//   // }
  const decls = file.getVariableDeclarations();
  for (const decl of decls) {
    const globalVariableName = decl.getStructure().name;
    // if (globalVariableName !== "Number") {
    //   // skipping others for now
    //   continue;
    // }
    const declType = decl.getType();
    if (declType.isNumber() || declType.isBoolean() || declType.isLiteral() || declType.isNull() || declType.isString() || declType.isUndefined() ) {
      globalPrimitiveDeclaration(
        globalVariableName,
        declType,
        appendToFile
      );
      continue;
    }
    if (true as any) {
      continue;
    }
    if (declType.isObject() === false) {
      continue
    }
    const isNormalCallable = declType.getCallSignatures().length > 0;
    const isConstructCallable = declType.getConstructSignatures().length > 0;
    // if ((isNormalCallable || isConstructCallable) === false) {
    // TODO: support creating bindings for things which are only normal callable or only construct callable
    if ((isNormalCallable && isConstructCallable) === false) {
      continue;
    }
    const swizzleOrWhiteListModel: SwizzleOrWhiteListEntry[] = [];
    const addCallOrConstructSigs = (signature: Signature, isConstructor: boolean) => {
      const paramExtractionCodes: ParamExtraction[] = extractParameters(signature.getParameters());
      const returnType = signature.getReturnType();
      const resultConversion: NativeToSValueConversionCode = convertTypeToSValue(returnType);
      swizzleOrWhiteListModel.push({
        kind: isConstructor ? "swizzled_raw_construct" : "swizzled_raw_apply",
        code_body: `${paramExtractionCodes.map(v=>v.setupCode).join("\n")}
const result: ${returnType.getText(undefined, TypeFormatFlags.UseFullyQualifiedType)} = ${isConstructor ? "new " : ""}${globalVariableName}(${paramExtractionCodes.map(v=>v.variableName).join(", ")});
const sResult: ${resultConversion.resultingSType} = ${resultConversion.convert("result")};
return sResult;
`
      })
    };
    const callSignatures = declType.getCallSignatures();
    if (callSignatures.length > 0) {
      // if (callSignatures.length > 1) {
      //   throw new Error(`Unexpectedly found more than 1 call signature. ${declType.getText()} ${callSignatures.map(v=>v.getDeclaration().getText())}`)
      // }
      const callSignature = callSignatures[0];
      addCallOrConstructSigs(callSignature, false);
    }
    const constructSignatures = declType.getConstructSignatures();
    if (constructSignatures.length > 0) {
      // if (constructSignatures.length > 1) {
      //   throw new Error("Unexpectedly found more than 1 construct signature.")
      // }
      const constructSignature = constructSignatures[0];
      addCallOrConstructSigs(constructSignature, true);
    }
    const typeProperties = declType.getProperties();
    for (const typeProperty of typeProperties) {
      const propertyName = typeProperty.getName();
      const propertyDeclarations = typeProperty.getDeclarations();
      if (propertyDeclarations.length !== 1) {
        console.log(`Handle more than 1 (or 0?) property declarations for whitelist/swizzling property ${propertyName}`)
        continue;
      }
      const propertyDeclaration = propertyDeclarations[0];
      const propertyType = propertyDeclaration.getType();
      if (propertyName === "prototype") {
        /// special treatment for prototype swizzling
        // todo
        continue;
      } else {
        // is a primitive
        if (propertyType.isBoolean() || propertyType.isNumber() || propertyType.isUndefined() || propertyType.isNull() || propertyType.isString()) {
          // whitelist it!
          // todo: force the user who is generating the bindings to opt-in to white listing for safety
          swizzleOrWhiteListModel.push({
            kind: "whitelist",
            property: propertyName
          });
          continue;
        } else {
          console.log(`Handle non-primitive whitelist/swizzling property ${propertyName} of type ${propertyType.getText()}`);
          continue;
        }
      }
    }
    let swizzleOrWhiteListModelStr = "";
    const appendToSwizzleOrWhiteListModelStrWithIndentation = makeAppendToFileWithIndentationFunction((str)=>swizzleOrWhiteListModelStr+=str);
    const appendToSwizzleOrWhiteListModelStr = appendToSwizzleOrWhiteListModelStrWithIndentation(2);
    // escapes if needed
    const makeSwizzleOrWhitelistProperty = (propertyName: string) => {
      if (isValidJsPropertyName(propertyName)) {
        return propertyName;
      } else {
        return `["${propertyName.replaceAll('"','\\"')}"]`;
      }
    };
    for (const swizzleOrWhiteListEntry of swizzleOrWhiteListModel) {
      switch (swizzleOrWhiteListEntry.kind) {
      case "hardcoded":
        appendToSwizzleOrWhiteListModelStr(swizzleOrWhiteListEntry.code + ",");
        continue;
      case "whitelist":
        appendToSwizzleOrWhiteListModelStr(`${makeSwizzleOrWhitelistProperty(`whitelist_${swizzleOrWhiteListEntry.property}`)}: true,`);
        continue;
      case "swizzled_raw_apply":
        appendToSwizzleOrWhiteListModelStr(`
swizzled_apply_raw(sThisArg: SValue<any> | undefined, sArgArray: SValue<any>[], newTarget: undefined, sTable: SLocalSymbolTable<any>) {
  ${swizzleOrWhiteListEntry.code_body.trim().split("\n").join("\n  ")}
},`);
        continue;
      case "swizzled_raw_construct":
        appendToSwizzleOrWhiteListModelStr(`
swizzled_construct_raw(_: undefined, sArgArray, newTarget: SFunction<any>, sTable: SLocalSymbolTable<any>) {
  ${swizzleOrWhiteListEntry.code_body.trim().split("\n").join("\n  ")}
},`);
        continue;
      default:
        console.log("TODO " + (swizzleOrWhiteListEntry as any).property);
      }
    }
    appendToFile(`
/// Native binding to global variable "${globalVariableName}".
rootSTable.assign("${globalVariableName}", SValues.SFunction.createFromNative(
  ${globalVariableName},
  {
    ${swizzleOrWhiteListModelStr.trim()}
  },
  new SValues.SNullValue(rootSTable.newMetadataForCompileTimeLiteral()), // todo: change to function
  rootSTable.newMetadataForCompileTimeLiteral()
), "const");
`);
  }
}
for (const fileToDoWorkOn of filesToDoWorkOn) {
  doFileWork(fileToDoWorkOn);
}

project.createSourceFile("test.ts",`let w = Number.NaN`);
const sourceFile = project.getSourceFiles()[0];
console.log(sourceFile.getVariableDeclarationOrThrow("w").getType().getText());

stream.write(`
};`);



type SwizzleOrWhiteListEntry = (HardCodedSwizzleOrWhiteListEntry | WhiteListEntry | SwizzledRawApply | SwizzledRawConstruct) & {
  kind: string
};
interface SwizzledRawApply {
  kind: "swizzled_raw_apply"
  code_body: string
}
interface SwizzledRawConstruct {
  kind: "swizzled_raw_construct"
  code_body: string
}
interface HardCodedSwizzleOrWhiteListEntry {
  kind: "hardcoded"
  code: string
}
interface WhiteListEntry {
  kind: "whitelist"
  property: string
}
